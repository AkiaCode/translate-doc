# [다차원 배열](@id man-multi-dim-arrays)

대부분의 기술 계산 언어와 마찬가지로, Julia는 일급 배열 구현을 제공한다.
대부분의 기술 계산 언어는 다른 컨테이너를 희생해 가면서도 배열의 구현에 많은 신경을 쓴다. 
Julia는 배열을 특별하게 취급하지는 않는다.
배열 라이브러리는 거의 전부 Julia로 작성되었으며, Julia로 쓰여진 다른 코드와 마찬가지로 컴파일러가 퍼포먼스를 결정한다.
따라서 `AbstractArray`로 부터 상속하여 커스텀 배열 타입을 정의하는 것도 가능하다.
커스텀 배열 타입을 구현하는 것의 세부사항은 [manual section on the AbstractArray interface](@ref man-interface-array) 를 참조하기 바란다.

배열은 다차원 그리드에 저장된 객체들의 모음이다.
가장 일반적인 경우, 배열은 `Any` 타입의 객체들을 담을 수 있다.
대부분의 계산 목적을 위해서는, 배열은 [`Float64`](@ref) 혹은 [`Int32`](@ref)와 같이 더 구체적인 타입의 객체를 담는 것이 좋다.

다른 많은 기술 계산 언어에서는 성능을 위해 프로그램을 벡터화된 스타일로 작성할 필요가 있지만, Julia에서는 일반적으로 그럴 필요가 없다.
Julia 컴파일러는 타입 추론을 사용하여 스칼라 배열 인덱싱에 최적화된 코드를 생성한다.
따라서 편리하고 읽기 쉬운 스타일로 프로그램을 작성하더라도 성능을 희생하지 않으며, 오히려 메모리를 더 적게 사용하는 경우도 있다.

Julia에서 모든 인수는 참조에 의해 전달된다(pass by reference).
어떤 기술적 계산 언어는 배열을 값에 의해 전달하는데(pass by value), 이렇게 하는 것이 편리한 경우도 많이 있다.
Julia에서는 함수 내에서 일어난 입력 배열의 변화를 부모 함수에서도 볼 수 있다.
Julia 배열 라이브러리의 어떤 코드도 입력 배열을 변경하지 않는다.
사용자의 코드가 이와 비슷하게 행동하도록 하려면, 변경될 수도 있는 배열을 복사하는 것에 소홀해서는 안된다.

## [배열](@id Arrays)

### 기본 함수

| 함수                   | 설명                                                           |
|:---------------------- |:-------------------------------------------------------------- |
| [`eltype(A)`](@ref)    | `A` 의 원소 타입                                               |
| [`length(A)`](@ref)    | `A` 의 원소 갯수                                               |
| [`ndims(A)`](@ref)     | `A` 의 차원수                                                  |
| [`size(A)`](@ref)      | `A` 의 크기 투플                                               |
| [`size(A,n)`](@ref)    | `A` 의 `n` 차원의 크기                                         |
| [`axes(A)`](@ref)      | `A` 의 유효한 인덱스 투플                                      |
| [`axes(A,n)`](@ref)    | `A` 의 유효 인덱스 `n`차원 범위(range)                         |
| [`eachindex(A)`](@ref) | `A` 의 모든 위치를 방문하는 효율적인 반복자(iterator)          |
| [`stride(A,k)`](@ref)  | `k` 차원 방향의 스트라이드 (연속한 원소 간의 선형 인덱스 거리) |
| [`strides(A)`](@ref)   | 모든 차원의 스트라이드 투플                                    |

### 생성과 초기화

배열을 생성하고 초기화 하는 많은 함수가 있다.
다음에 나열된 함수들에서, `dims...` 인수는 차원의 크기들을 나타내는 투플 하나를 받거나, 혹은 각 차원의 크기를 여러 인수로 받을 수 있다.
이 함수들의 대부분은 첫번째 인수로 배열의 원소 타입 `T`를 받을 수 있다.
`T`가 생략되었다면 [`Float64`](@ref)가 기본값이다.

| 함수                                       | 설명                                                                                                                                                               |
|:------------------------------------------ |:------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [`Array{T}(uninitialized, dims...)`](@ref) | 초기화 되지 않은 밀집 [`Array`](@ref)                                                                                                                              |
| [`zeros(T, dims...)`](@ref)                | 모든 값이 0으로 초기화 된 `Array`                                                                                                                                  |
| [`ones(T, dims...)`](@ref)                 | 모든 값이 1로 초기화 된 `Array`                                                                                                                                    |
| [`trues(dims...)`](@ref)                   | 모든 값이 `true`로 초기화 된 [`BitArray`](@ref)                                                                                                                    |
| [`falses(dims...)`](@ref)                  | 모든 값이 `false`로 초기화 된 `BitArray`                                                                                                                           |
| [`reshape(A, dims...)`](@ref)              | `A` 와 동일한 데이타를 가지고 있지만 형상이 다른 배열                                                                                                              |
| [`copy(A)`](@ref)                          | `A` 의 얕은 복사                                                                                                                                                   |
| [`deepcopy(A)`](@ref)                      | `A` 의 깊은 복사 (모든 원소를 재귀적으로 복사함)                                                                                                                   |
| [`similar(A, T, dims...)`](@ref)           | `A` 와 동일한 종류(밀집, 희소, 등)의 초기화 되지 않은 배열. 지정된 원소 타입과 형상을 가짐. 두번째와 세번째 인수는 선택적이며, 기본값은 `A`의 원소타입과 차원이다. |
| [`reinterpret(T, A)`](@ref)                | `A` 와 동일한 이진 데이터를 가지고 있지만, 원소 타입이 `T` 인 배열                                                                                                 |
| [`rand(T, dims...)`](@ref)                 | 독립 동일하며 열린구간 ``[0, 1)`` 상에서 연속 균일 분포를 가진 랜덤 `Array`                                                                                        |
| [`randn(T, dims...)`](@ref)                | 독립 동일하며 표준 정규 분포를 가진 랜덤 `Array`                                                                                                                   |
| [`Matrix{T}(I, m, n)`](@ref)               | 크기가 `m` × `n` 인 단위 행렬                                                                                                                                      |
| [`linspace(start, stop, n)`](@ref)         | `start`에서 `stop`까지 `n` 개의 원소가 선형적으로 배치된 구간                                                                                                      |
| [`fill!(A, x)`](@ref)                      | 배열 `A` 를 `x` 값으로 채우기                                                                                                                                      |
| [`fill(x, dims...)`](@ref)                 | `x` 값으로 차 있는 `Array`                                                                                                                                         |

`[A, B, C, ...]` 문법은 주어진 인수들의 일차원 배열(벡터)을 생성한다.
만약 모든 인수가 공통의 [확장 타입(promotion type)](@ref conversion-and-promotion)을 가진다면, 이들은 `convert`를 통해 공통의 확장 타입으로 변환된다.

### 병합(Concatenation)

배열은 다음의 함수를 사용하여 생성하고 병합할 수 있다.

| 함수                   | 설명                                  |
|:---------------------- |:------------------------------------- |
| [`cat(k, A...)`](@ref) | n차원 입력 배열을 `k`차원을 따라 병합 |
| [`vcat(A...)`](@ref)   | `cat(1, A...)`의 줄임                 |
| [`hcat(A...)`](@ref)   | `cat(2, A...)`의 줄임                 |

스칼라 값이 인수로 전달되면 원소 갯수가 하나인 배열로 취급한다.

병합 함수는 자주 사용되므로 다음의 특별한 문법을 가진다:

| 표현식            | 함수            |
|:----------------- |:--------------- |
| `[A; B; C; ...]`  | [`vcat`](@ref)  |
| `[A B C ...]`     | [`hcat`](@ref)  |
| `[A B; C D; ...]` | [`hvcat`](@ref) |

[`hvcat`](@ref) 은 1차원 (세미콜론으로 구분) 과 2차원(스페이스로 구분) 모두 병합한다.

### 타입이 있는 배열의 초기화

특정 원소 타입의 배열은 `T[A, B, C, ...]` 문법을 통해 생성할 수 있다.
이는 원소 타입이 `T`인 일차원 배열을 생성하고, 원소 `A`, `B`, `C` 등을 담도록 초기화한다.
예를 들어 `Any[x, y, z]`는 어떤 값이든 가질 수 있는 배열을 생성한다.

병합 구문 또한 비슷한 방법으로 원소 타입을 지정할 수 있다.

```jldoctest
julia> [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia> Int8[[1 2] [3 4]]
1×4 Array{Int8,2}:
 1  2  3  4
```

### [컴프리헨션(Comprehensions)](@id Comprehensions)

컴프리헨션은 배열을 생성하는 일반적이면서도 강력한 방법을 제공한다.
컴프리헨션의 문법은 수학에서 쓰이는 집합의 조건제시법과 유사하다:

```
A = [ F(x,y,...) for x=rx, y=ry, ... ]
```

이는 `x`, `y` 등의 변수가 주어진 목록의 값을 각각 가지도록 하여 `F(x,y,...)`를 계산한다는 뜻이다.
값의 목록은 반복 가능한(iterable) 어떤 객체도 될 수 있지만, 주로 `1:n` 혹은 `2:(n-1)` 와 같은 범위이거나, `[1.2, 3.4, 5.7]`와 같이 명시적인 값의 배열이다.
결과는 N차원 배열이며, 그 크기는 변수의 범위인 `rx`, `ry` 등의 크기를 병합한 것과 같다.
그리고 각 `F(x,y,...)` 계산은 스칼라 값을 리턴한다.

다음의 예는 일차원 그리드에서, 현재 원소와 왼쪽 이웃, 오른쪽 이웃의 가중 평균을 계산한다:

```julia-repl
julia> x = rand(8)
8-element Array{Float64,1}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia> [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511
```

결과 배열의 타입은 계산된 원소가 결정한다.
타입을 명시적으로 정하려면 컴프리헨션 앞에 타입을 붙이면 된다.
예를 들어, 다음과 같이 결과를 단정밀도(single precision)로 요청할 수 있다:

```julia
Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
```

### 제너레이터 표현식 (Generator Expressions)

컴프리헨션은 대괄호 없이도 쓸 수 있으며, 이 경우 제너레이터 객체를 생성한다.
제너레이터는 배열을 미리 할당하고 값을 저장하는 것이 아니라, 필요에 따라 값을 생성하도록 반복할 수 있다 ([반복](@ref Iteration) 참조).
예를 들어, 다음의 표현식은 메모리 할당 없이 수열의 합을 계산한다:

```jldoctest
julia> sum(1/n^2 for n=1:1000)
1.6439345666815615
```

인수 목록 안에서 다차원 제너레이터 표현식을 사용할 때에는 괄호를 사용하여 그 다음의 인수와 구분한다:

```julia-repl
julia> map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification
```

`for` 다음에 나오는 쉼표로 구분된 모든 표현식은 범위로 해석되므로, 여기에 괄호를 추가함으로써 `map`에 세번째 인수를 추가할 수 있다.

```jldoctest
julia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Array{Tuple{Float64,Int64},2}:
 (0.5, 1)       (0.333333, 3)
 (0.333333, 2)  (0.25, 4)
```

제너레이터와 컴프리헨션에서 `for` 키워드를 여러번 사용함으로써 범위가 앞선 범위에 의존하도록 할 수 있다.

```jldoctest
julia> [(i,j) for i=1:3 for j=1:i]
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)
```

이러한 경우 결과는 항상 1차원이다.

생성된 값은 `if` 키워드를 사용하여 필터링 할 수 있다.

```jldoctest
julia> [(i,j) for i=1:3 for j=1:i if i+j == 4]
2-element Array{Tuple{Int64,Int64},1}:
 (2, 2)
 (3, 1)
```

### [인덱싱](@id man-array-indexing)

n차원 배열 `A`를 인덱싱 하는 일반적인 문법은 다음과 같다:

```
X = A[I_1, I_2, ..., I_n]
```

여기서 `I_k` 는 스칼라 정수, 정수의 배열, 혹은 [지원하는 다른 인덱스](@ref man-supported-index-types) 중 하나이다.
여기에는 모든 인덱스를 선택하는 [`Colon`](@ref) (`:`), 연속되거나 일정한 간격의 부분수열을 선택하는 `a:c` 혹은 `a:b:c`와 같은 형태의 범위, 그리고 `true` 값을 선택하는 부울 배열도 포함된다.

만약 모든 인덱스가 스칼라라면, 결과 `X`는 배열 `A`의 원소 중 하나이다.
그렇지 않을 경우 `X`는 배열이며, 모든 인덱스의 차원 수의 합이 `X`의 차원수가 된다.

예를들어 만약 모든 인덱스가 벡터라면 `X`의 크기는 `(length(I_1), length(I_2), ..., length(I_n))`가 되고, `X`의 `(i_1, i_2, ..., i_n)` 위치는  `A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]` 값을 가지게 된다.
만약 `I_1`이 2차원 행렬로 바뀐다면, `X`는 크기가 `(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))`인 `n+1`차원 배열이 된다.
행렬이 차원을 하나 추가하는 것이다.
`X`의 `(i_1, i_2, i_3, ..., i_{n+1})` 위치는 `A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]` 값을 가진다.
스칼라 인덱스를 가진 모든 차원은 결과에서 빠진다.
예를 들어, `A[2, I, 3]`의 결과는 크기가 `size(I)`인 배열이며, `i`번째 원소의 값은 `A[2, I[i], 3]`이다.

인덱싱 문법의 특수한 한 부분으로서, 각 차원의 마지막 인덱스를 나타내기 위해서 인덱싱 괄호 안에서 `end` 키워드를 사용할 수 있다.
마지막 인덱스는 인덱싱 되는 가장 안쪽의 배열의 크기에 따라 결정된다.
`end` 키워드 없는 인덱싱 문법은 [`getindex`](@ref) 호출과 동일하다:

```
X = getindex(A, I_1, I_2, ..., I_n)
```

예시:

```jldoctest
julia> x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> x[2:3, 2:end-1]
2×2 Array{Int64,2}:
 6  10
 7  11

julia> x[1, [2 3; 4 1]]
2×2 Array{Int64,2}:
  5  9
 13  1
```

`n:n-1`과 같은 식의 빈 범위는 인덱스 `n-1`과 `n`사이의 위치를 나타내기 위해 가끔 사용된다.
예를 들어, [`searchsorted`](@ref) 함수는 이 방법을 사용하여 정렬된 배열에 없는 값의 삽입 위치를 나타낸다.

```jldoctest
julia> a = [1,2,5,6,7];

julia> searchsorted(a, 3)
3:2
```

### 대입

n차원 배열 `A`에 값을 대입하는 일반적인 문법은 다음과 같다:

```
A[I_1, I_2, ..., I_n] = X
```

여기서 `I_k` 는 스칼라 정수, 정수의 배열, 혹은 [지원하는 다른 인덱스](@ref man-supported-index-types) 중 하나이다.
여기에는 모든 인덱스를 선택하는 [`Colon`](@ref) (`:`), 연속되거나 일정한 간격의 부분수열을 선택하는 `a:c` 혹은 `a:b:c`와 같은 형태의 범위, 그리고 `true` 값을 선택하는 부울 배열도 포함된다.

만약 `X`가 배열이라면, 그 원소의 갯수는 모든 인덱스 길이의 곱인 `prod(length(I_1), length(I_2), ..., length(I_n))`와 같아야 한다.
`A`의 `I_1[i_1], I_2[i_2], ..., I_n[i_n]` 위치에 있는 값은 `X[i_1, i_2, ..., i_n]` 값으로 덮어쓰인다.
만약 `X`가 배열이 아니라면, `A`의 참조된 모든 위치에 `X`의 값이 대입된다.

[인덱싱](@ref man-array-indexing)에서와 마찬가지로, 각 차원의 마지막 인덱스를 나타내기 위해서 인덱싱 괄호 안에서 `end` 키워드를 사용할 수 있다.
마지막 인덱스는 인덱싱 되는 가장 안쪽의 배열의 크기에 따라 결정된다.
`end` 키워드 없는 대입의 문법은 [`setindex!`](@ref) 호출과 동일하다:

```
setindex!(A, X, I_1, I_2, ..., I_n)
```

예시:

```jldoctest
julia> x = collect(reshape(1:9, 3, 3))
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9

julia> x[1:2, 2:3] = -1
-1

julia> x
3×3 Array{Int64,2}:
 1  -1  -1
 2  -1  -1
 3   6   9
```

### [지원하는 인덱스 타입](@id man-supported-index-types)

표현식 `A[I_1, I_2, ..., I_n]`에서, `I_k`는 스칼라 인덱스, 스칼라 인덱스의 배열, 혹은 [`to_indices`](@ref)를 통해 스칼라 인덱스 배열로 변환될 수 있는 객체 중 하나이다:

1. 스칼라 인덱스. 다음을 포함한다:
    * 부울이 아닌 정수.
    * [`CartesianIndex{N}`](@ref). 여러 차원에 걸쳐있는 정수의 `N`투플처럼 행동한다. (자세한 내용은 아래를 참조.)
2. 스칼라 인덱스의 배열. 다음을 포함한다:
    * 정수 벡터와 다차원 정수 배열.
    * `[]`와 같은 빈 배열. 아무 원소도 선택하지 않는다.
    * `a:c` 나 `a:b:c`와 같은 범위. `a` 와 `c` 사이의 연속되거나 일정 간격의 subsection을 선택.
    * `AbstractArray`의 서브타입인 배열 스칼라의 .
    * `CartesianIndex{N}`의 배열 (자세한 내용은 아래를 참조).
3. 스칼라 인덱스의 배열을 나타내는 객체이면서 [`to_indices`](@ref)를 통해 스칼라 인덱스의 배열로 변환될 수 있는 것. 기본으로 다음을 포함한다:
    * [`Colon()`](@ref) (`:`). 차원 혹은 배열의 모든 원소를 선택한다.
    * 부울 배열. `true` 인덱스에 있는 원소를 선택한다.

#### 직교 인덱스(Cartesian indices)

`CartesianIndex{N}` 객체는 여러 차원을 포괄하는 정수의 `N`투플처럼 동작하는 스칼라 인덱스를 나타낸다.

```jldoctest cartesianindex
julia> A = reshape(1:32, 4, 4, 2);

julia> A[3, 2, 1]
7

julia> A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7
true
```

따로 떼어놓고 생각했을때, 이는 매우 간단하게 보일지도 모른다;
`CartesianIndex`는 단순히 여러 정수를 하나의 객체로 묶어서 하나의 다차원 인덱스로 나타내는 것이다.
하지만 다른 형식의 인덱싱이나, `CartesianIndex`를 내어놓는 반복자와 결합하면 매우 우아하고 효율적인 코드를 쓸 수 있다.
아래의 [반복자](@ref Iteration)를 참조하라.
더 고급 예시는 [다차원 알고리즘과 반복에 관한 이 블로그](https://julialang.org/blog/2016/02/iteration)를 참조하라.

`CartesianIndex{N}`의 배열 또한 지원된다.
이는 각각 `N`차원을 포괄하는 스칼라 인덱스의 모음을 나타나며, 점별(pointwise) 인덱싱이라고도 불리는 인덱싱의 형태를 가능하게 한다.
예를 들어, 앞선 예시에서 정의된 `A`의 첫 "페이지"의 대각원소들을 다음과 같이 엑세스 할 수 있다:

```jldoctest cartesianindex
julia> page = A[:,:,1]
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> page[[CartesianIndex(1,1),
             CartesianIndex(2,2),
             CartesianIndex(3,3),
             CartesianIndex(4,4)]]
4-element Array{Int64,1}:
  1
  6
 11
 16
```

이는 [점 브로드캐스팅](@ref man-vectorized)을 정수 인덱스와 함께 씀으로써 (`A`로 부터 첫번째 "페이지"를 추출하는 별도의 과정 없이) 더욱더 간단하게 표한할 수 있다.
뿐만 아니라 `:`와 결합하여 두 페이지의 대각원소들을 한번에 추출할 수도 있다:

```jldoctest cartesianindex
julia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]
4-element Array{Int64,1}:
  1
  6
 11
 16

julia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]
4×2 Array{Int64,2}:
  1  17
  6  22
 11  27
 16  32
```

!!! 경고

    `CartesianIndex`와 `CartesianIndex`의 배열은 차원의 마지막 인덱스를 나타내는 `end` 키워드와 호환되지 않으므로, `CartesianIndex` 혹은 `CartesianIndex`의 배열을 포함할 수도 있는 표현식에서는 `end`를 사용해서는 안된다.

#### 논리적 인덱싱

부울 배열을 이용한 인덱싱은 값이 `true`인 곳의 인덱스를 선택한다.
주로 논리적 인덱싱, 혹은 논리적 마스크를 사용한 인덱싱이라고 부르며, 부울 벡터 `B`를 통한 인덱싱은 [`find(B)`](@ref)가 리턴하는 정수의 벡터를 통한 인덱싱과 동일하다.
이와 마찬가지로, `N`차원 부울 배열을 통한 인덱싱은, `true` 값의 위치를 나타내는 `CartesianIndex{N}`들의 배열을 통한 인덱싱과 동일하다.
논리적 인덱스는, 인덱스의 크기와 인덱스하는 배열의 해당 차원의 크기가 일치하거나, 혹은 배열과 크기 및 차원이 일치하는 단 하나의 인덱스이어야 한다.
부울 배열을 사용하여 바로 인덱싱 하는 것이 [`find`](@ref)를 먼저 호출하는 것보다 일반적으로 더 효율적이다.

```jldoctest
julia> x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> x[[false, true, true, false], :]
2×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15

julia> mask = map(ispow2, x)
4×4 Array{Bool,2}:
  true  false  false  false
  true  false  false  false
 false  false  false  false
  true   true  false   true

julia> x[mask]
5-element Array{Int64,1}:
  1
  2
  4
  8
 16
```

### [반복(Iteration)](@id Iteration)

배열 전체를 반복하는 방법으로는 다음을 추천한다:

```julia
for a in A
    # 원소 a로 뭔가 한다
end

for i in eachindex(A)
    # i 혹은 A[i] 로 뭔가 한다
end
```

첫번째 구문은 인덱스가 아니라 값이 필요할 때 사용한다.
두번째 구문에서 `A`가 빠른 선형 인덱싱을 지원하는 배열이라면 `i`는 `Int` 타입, 그렇지 않을 경우는 `CartesianIndex` 타입이다:

```jldoctest
julia> A = rand(4,3);

julia> B = view(A, 1:3, 2:3);

julia> for i in eachindex(B)
           @show i
       end
i = CartesianIndex(1, 1)
i = CartesianIndex(2, 1)
i = CartesianIndex(3, 1)
i = CartesianIndex(1, 2)
i = CartesianIndex(2, 2)
i = CartesianIndex(3, 2)
```

`for i = 1:length(A)`에 비해, [`eachindex`](@ref)는 모든 종류의 배열을 효율적으로 반복할 수 있도록 해준다.

### 배열 특성(trait)

커스텀 [`AbstractArray`](@ref) 타입을 정의하는 경우, 빠른 선형 인덱싱이 가능함을 지정할 수 있다:

```julia
Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()
```

이 설정은 `eachindex`가 정수를 사용하여 `MyArray`를 반복하도록 한다.
이 특성을 지정하지 않으면, 기본값인 `IndexCartesian()`를 사용한다.

### 배열과 벡터화된 연산자/함수

배열은 다음의 연산자를 지원한다:

1. 단항 산술 연산자 -- `-`, `+`
2. 이항 산술 연산자 -- `-`, `+`, `*`, `/`, `\`, `^`
3. 비교 연산자 -- `==`, `!=`, `≈` ([`isapprox`](@ref)), `≉`

위에 나열된 대부분의 이항 산술 연산자는 하나의 인수가 스칼라일때도 원소별 연산을 한다:
`-`, `+`, `*`는 두 인수 중 어느 한쪽이 스칼라인 경우, 그리고 `/` 와 `\` 는 분모가 스칼라 인 경우를 지원한다.
예를 들면 다음과 같다: `[1, 2] + 3 == [4, 5]` 그리고 `[6, 4] / 2 == [3, 2]`.

또한 배열, 혹은 배열과 스칼라의 혼합에 대한 원소별 연산에 대해
또한, `f.(args...)` 형태의 (예: `sin.(x)`, `min.(x,y)`) [점 문법](@ref man-vectorized)을 사용하여 수학 연산과 다른 연산을 편리하게 벡터화 할 수 있다;
배열, 혹은 배열과 스칼라의 혼합에 대해 원소별 연산을 하기 위해서 점 문법을 쓸 수 있다 ([브로드캐스팅](@ref Broadcasting) 연산).
추가적인 이점으로는 다른 dot call 과 같이 쓴다면 하나의 루프로 융합한다는 것이다 (예: `sin.(cos.(x))`).

또한, *모든* 이항 연산자는 [점을 찍어](@ref man-dot-operators)사용할 수 있으며, 이는 [융합 브로드캐스팅 연산](@ref man-vectorized)에서 배열(그리고 배열과 스칼라의 조합)에 적용할 수 있다 (예: `z .== sin.(x .* y)`).

참고로, `==` 와 같은 연산자는 전체 배열에 적용되어, 단 하나의 부울 값을 내어놓는다.
원소별 비교를 위해서는 점 `.==`와 같은 점 연산자를 사용하라.
(`<`와 같은 비교 연산은, 원소별 연산 `.<`*만*이 배열에 적용 가능하다.)

또한,  [`max`](@ref)를 `a`와 `b`에 원소별로 [`broadcast`](@ref) 하는 `max.(a,b)`와 , `a`의 최대값을 찾는 [`maximum(a)`](@ref)의 차이에 유의하라.
`min.(a,b)` 와 `minimum(a)` 의 관계도 마찬가지이다.

### [브로드캐스팅](@id Broadcasting)

행렬의 각 배열을 더하는 것 처럼, 다른 크기의 배열들을 원소별로 이항 연산할 필요가 종종 있다.
이를 비효율적으로 하는 방법은 벡터를 행렬과 같은 크기로 복사하는 것이다:

```julia-repl
julia> a = rand(2,1); A = rand(2,3);

julia> repmat(a,1,3)+A
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846
```

차원의 크기가 커지면 위 방법은 낭비가 심해지므로, Julia는 [`broadcast`](@ref)를 제공한다.
`broadcast`는 추가적인 메모리를 사용하지 않으면서, 주어진 한 배열의 차원 중 크기가 1인 차원을 주어진 다른 배열의 해당 차원의 크기와 일치하도록 확장하여 주어진 함수를 원소별로 적용하는 함수이다:

```julia-repl
julia> broadcast(+, a, A)
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia> b = rand(1,2)
1×2 Array{Float64,2}:
 0.867535  0.00457906

julia> broadcast(+, a, b)
2×2 Array{Float64,2}:
 1.71056  0.847604
 1.73659  0.873631
```

`.+` 와 `.*` 같은 [점찍은 연산자](@ref man-dot-operators)는 `broadcast` 호출과 (아래에 설명할 융합을 제외한다면) 동일하다.
또한 명시적으로 목적지를 지정하는 [`broadcast!`](@ref)도 있다.
(`.=` 대입을 사용하여 융합하여서도 액세스할 수 있다.)
그리고 [`broadcast_getindex`](@ref)와 [`broadcast_setindex!`](@ref) 함수는 인덱싱 전에 인덱스를 브로드캐스팅 한다.
게다가, `f.(args...)`는 `broadcast(f, args...)`와 동일하며, 어떤 함수든 [점 문법](@ref man-vectorized)을 통하여 편리하게 브로드캐스팅 할 수 있는 문법을 제공한다.
중첩된 "점 호출" `f.(...)`은 (`.+` 등의 연산자도 포함하여) 하나의 `broadcast` 호출로 [자동으로 융합](@ref man-dot-operators)한다.

추가적으로, [`broadcast`](@ref)는 배열에 국한되지 않고 (함수 문서 참조) 투플 또한 지원하며,
배열, 투플, [`Ref`](@ref)([`Ptr`](@ref) 제외)가 아닌 모든 값은 "스칼라"로 취급한다.

```jldoctest
julia> convert.(Float32, [1, 2])
2-element Array{Float32,1}:
 1.0f0
 2.0f0

julia> ceil.((UInt8,), [1.2 3.4; 5.6 6.7])
2×2 Array{UInt8,2}:
 0x02  0x04
 0x06  0x07

julia> string.(1:3, ". ", ["First", "Second", "Third"])
3-element Array{String,1}:
 "1. First"
 "2. Second"
 "3. Third"
```

### 구현

Julia에서 기본 배열 타입은 추상 타입인 [`AbstractArray{T,N}`](@ref)이다.
`AbstractArray{T,N}`는 차원수 `N`과 원소 타입 `T`로 매개변수화 되어 있다.
[`AbstractVector`](@ref)와 [`AbstractMatrix`](@ref)는 일차원과 이차원 배열의 앨리어스(alias)이다.
`AbstractArray` 객체에 대한 연산은 기저 스토리지에 독립적인 형태로 고수준의 연산자와 함수를 사용하여 정의된다.
이 연산은 일반적으로 구체적 배열 구현의 폴백(fallback)으로서 정상동작한다.

`AbstractArray` 타입은 배열과 비슷한 모든 것을 포함하며, 이들의 구현은 전통적인 배열과는 차이가 많이 날 수도 있다.
예를 들어, 원소를 저장하지 않고 요청에 따라서 계산할 수도 있다.
다만 모든 구체적인 `AbstractArray{T,N}` 타입은 일반적으로 적어도 (`Int` 투플을 리턴하는) [`size(A)`](@ref),
[`getindex(A,i)`](@ref), 그리고 [`getindex(A,i1,...,iN)`](@ref getindex)를 구현해야 한다.
변경 가능한 배열은 [`setindex!`](@ref)도 구현해야 한다.
이러한 연산들은 대략 상수 시간 복잡도, 엄밀히 말해 Õ(1) 복잡도를 가지도록 구현하는 것이 좋다.
그렇지 않으면 어떤 배열 함수는 생각 이상으로 느릴지도 모른다.
구체적 타입은 [`copy`](@ref)등의 out-of-place 연산에서 유사한 배열을 할당하는데에 쓰일 수 있는 [`similar(A,T=eltype(A),dims=size(A))`](@ref)메소드를 제공해야 한다.
`AbstractArray{T,N}`가 내부적으로 어떻게 표현이 되든, `T` 는 *정수* 인덱싱이 리턴하는 객체(`A` 가 빈 배열이 아닌 경우 `A[1, ..., 1]`)의 타입이며, `N`은 [`size`](@ref)가 리턴하는 투플의 길이여야 한다.

`DenseArray`는 `AbstractArray`의 추상 서브타입으로, 원소가 메모리에 규칙적인 오프셋으로 배치된 배열 모두를 포함하고자 만들어졌으며,
따라서 이러한 메모리 레이아웃을 기대하는 외부의 C나 Fortran함수에 전달될 수도 있다.
`DenseArray`의 서브 타입은 `k`차원의 스트라이드를 리턴하는 [`stride(A,k)`](@ref)를 제공해야 한다:
`k`차원의 인덱스를 1만큼 늘리면 [`getindex(A,i)`](@ref)의 인덱스 `i`를 [`stride(A,k)`](@ref)만큼 늘리는 것과 동일하다.
포인터 변환 메소드 [`Base.unsafe_convert(Ptr{T}, A)`](@ref)가 제공된다면, 메모리 레이아웃 또한 같은 식으로 스트라이드를 따라야 한다.

[`Array`](@ref) 타입은 `DenseArray`의 구체적 인스턴스로서, 원소들은 열 우선 순서(column-major order)로 저장된다.
([성능 향상 팁](@ref man-performance-tips) 참조)
[`Vector`](@ref)와 [`Matrix`](@ref)는 1차원과 2차원 [`Array`](@ref)의 앨리어스이다.
배열 라이브러리의 다른 부분이 일반적인 방식으로 구현될 수 있도록, 스칼라 인덱싱과 대입 및 몇개의 기본적인 스토리지 특정 연산이 [`Array`](@ref)에 구현되어야 한다.

`SubArray`는 복사가 아닌 참조로 인덱싱을 수행하는 `AbstractArray`의 특수화이다.
`SubArray`는 [`view`](@ref)함수로 생성되는데, 호출 방식은 [`getindex`](@ref)와 같다.
[`view`](@ref)의 결과는 [`getindex`](@ref)와 똑같이 보이나, 데이터가 복사되지 않는다는 차이점이 있다.
[`view`](@ref)는 입력 인덱스 벡터를 `SubArray` 객체에 저장하는데, 이는 참조되는 원 배열을 나중에 간접적으로 인덱싱 하는데에 쓰인다.
[`@views`](@ref) 매크로를 표현식이나 코드 블록 앞에 둠으로써, 그 표현식 내의 모든 `array[...]` 슬라이스가 `SubArray` 뷰를 생성하도록 할 수 있다.

`StridedVector`와 `StridedMatrix`는 Julia가 BLAS와 LAPACK 함수를 호출 할 때 [`Array`](@ref) 혹은 `SubArray` 객체를 전달할 수 있게 해주는 편리한 앨리어스이며, 따라서 메모리 할당과 복사에 의한 비효율성을 줄일 수 있도록 해준다.

다음 예시에서는 임시 배열을 만들지 않고 적절한 LAPACK 함수를 차원 크기와 스트라이드를 사용하여 호출하여 큰 배열의 작은 섹션의 QR 분해를 계산한다.

```julia-repl
julia> a = rand(10,10)
10×10 Array{Float64,2}:
 0.561255   0.226678   0.203391  0.308912   …  0.750307  0.235023   0.217964
 0.718915   0.537192   0.556946  0.996234      0.666232  0.509423   0.660788
 0.493501   0.0565622  0.118392  0.493498      0.262048  0.940693   0.252965
 0.0470779  0.736979   0.264822  0.228787      0.161441  0.897023   0.567641
 0.343935   0.32327    0.795673  0.452242      0.468819  0.628507   0.511528
 0.935597   0.991511   0.571297  0.74485    …  0.84589   0.178834   0.284413
 0.160706   0.672252   0.133158  0.65554       0.371826  0.770628   0.0531208
 0.306617   0.836126   0.301198  0.0224702     0.39344   0.0370205  0.536062
 0.890947   0.168877   0.32002   0.486136      0.096078  0.172048   0.77672
 0.507762   0.573567   0.220124  0.165816      0.211049  0.433277   0.539476

julia> b = view(a, 2:2:8,2:2:4)
4×2 SubArray{Float64,2,Array{Float64,2},Tuple{StepRange{Int64,Int64},StepRange{Int64,Int64}},false}:
 0.537192  0.996234
 0.736979  0.228787
 0.991511  0.74485
 0.836126  0.0224702

julia> (q,r) = qr(b);

julia> q
4×2 Array{Float64,2}:
 -0.338809   0.78934
 -0.464815  -0.230274
 -0.625349   0.194538
 -0.527347  -0.534856

julia> r
2×2 Array{Float64,2}:
 -1.58553  -0.921517
  0.0       0.866567
```

## 희소 벡터와 행렬

Julia는 희소 벡터와 [희소 행렬](https://ko.wikipedia.org/wiki/%ED%9D%AC%EC%86%8C%ED%96%89%EB%A0%AC)을 자체적으로 지원한다.
희소 배열이란 0인 원소가 충분히 많아 특별한 자료구조로 저장하는 편이 밀집 배열에 비해서 공간과 실행 시간이 절약되는 배열을 말한다.

### [Compressed Sparse Column (CSC) 희소 행렬 저장법](@id man-csc)

Julia에서 희소 행렬은 [Compressed Sparse Column (CSC) 포맷](https://ko.wikipedia.org/wiki/%ED%9D%AC%EC%86%8C%ED%96%89%EB%A0%AC#Compressed_sparse_column_.28CSC_or_CCS.29)으로 저장된다.
Julia에서 희소 행렬은 [`SparseMatrixCSC{Tv,Ti}`](@ref) 타입이며, `Tv`는 저장된 값의 타입, `Ti`는 행 인덱스와 열을 가리키는 포인터를 저장하는 정수의 타입이다.
`SparseMatrixCSC`의 내부 표현은 다음과 같다:

```julia
struct SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}
    m::Int                  # 행의 수
    n::Int                  # 열의 수
    colptr::Vector{Ti}      # i번째 열은 colptr[i]:(colptr[i+1]-1)에 위치한다.
    rowval::Vector{Ti}      # 저장된 값의 열 인덱스
    nzval::Vector{Tv}       # 저장된 값. 대체로 0이 아니다.
end
```

CSC 저장법은 희소 행렬의 각 열을 쉽게 엑세스 할 수 있도록 해 주지만, 반면에 행을 엑세스 하는 것은 훨씬 느리다.
새로운 엔트리를 하나씩 삽입하는 것은 CSC 구조에서 느린데, 이는 삽입점 이후의 모든 엔트리가 한칸씩 옮겨져야 하기 때문이다.

희소 행렬의 모든 연산은 CSC 자료구조를 최대한 이용하면서 비싼 연산은 피하도록 신중하게 구현되었다.

다른 애플리케이션이나 라이브러리에서 생성된 CSC 포맷의 데이터를 Julia에서 가져오려면 1기반 인덱싱을 사용하는지 확인해야 한다.
각 열의 행 인덱스는 정렬되어야 한다.
만약 `SparseMatrixCSC` 객체가 정렬되지 않은 행 인덱스를 가지고 있다면, 두번 전치(transpose)함으로써 빠르게 정렬할 수 있다.

`SparseMatrixCSC`에 0값을 명시적으로 저장하는 것이 편리한 경우도 있다.
이렇게 하는 것 또한 `Base`의 함수들이 *허용하며* (단, 변환의 과정에서 반드시 남아있을 보장은 없다.),
그렇게 명시적으로 저장된 0은 많은 루틴이 "구조적으로는 0이 아닌" 것으로 취급한다.
[`nnz`](@ref) 함수는 명시적으로 저장된 0이 아닌 엔트리의 갯수(구조적으로 0이 아닌 엔트리를 포함하여)를 리턴한다.
수치적으로 0이 아닌 엔트리의 갯수를 정확히 얻기 위해서는 저장된 모든 엔트리를 검사하는 [`count(!iszero, x)`](@ref)를 사용하라.
희소 행렬에 저장된 0값은 [`dropzeros`](@ref) 와 in-place 함수인 [`dropzeros!`](@ref)를 이용해 삭제할 수 있다.

```jldoctest
julia> A = sparse([1, 2, 3], [1, 2, 3], [0, 2, 0])
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  0
  [2, 2]  =  2
  [3, 3]  =  0

julia> dropzeros(A)
3×3 SparseMatrixCSC{Int64,Int64} with 1 stored entry:
  [2, 2]  =  2
```

### 희소 벡터 스토리지

희소 벡터는 희소 행렬의 CSC 포맷과 매우 유사한 방식으로 저장된다.
Julia에서 희소 행렬은 [`SparseVector{Tv,Ti}`](@ref) 타입을 가지는데 `Tv`는 저장된 값의 타입, `Ti`는 인덱스의 정수 타입이다.
`SparseVector`의 내부 표현은 다음과 같다:

```julia
struct SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}
    n::Int              # 희소 행렬의 길이
    nzind::Vector{Ti}   # 저장된 값의 인덱스
    nzval::Vector{Tv}   # 저장된 값. 대체로 0이 아니다.
end
```

[`SparseMatrixCSC`](@ref)와 마찬가지로 `SparseVector`도 명시적으로 0을 담을 수 있다.
([희소 행렬 저장법](@ref man-csc) 참조)

### 희소 벡터와 행렬 생성자

희소 배열을 가장 간단히 만드는 방법은, 밀집 배열의 [`zeros`](@ref)에 해당하는 함수를 사용하는 것이다.
희소 배열을 만들 때에는 해당하는 밀집 배열의 함수명에 `sp` 접두어를 붙이면 된다:

```jldoctest
julia> spzeros(3)
3-element SparseVector{Float64,Int64} with 0 stored entries
```

[`sparse`](@ref) 함수를 사용하여 편리하게 희소배열을 생성할 수 있다.
에를 들어, 희소 행열을 생성하려면 행 인덱스를 담은 벡터 `I`와, 열 인덱스를 담은 벡터 `J`와, 값을 담은 벡터 `V`를 입력하면 된다.
(이는 [COO 포맷](https://ko.wikipedia.org/wiki/%ED%9D%AC%EC%86%8C%ED%96%89%EB%A0%AC#Coordinate_list_.28COO.29)으로도 알려져있다.)
`sparse(I,J,V)`는 `S[I[k], J[k]] = V[k]`를 만족하는 희소행렬을 생성한다.
이와 마찬가지로 [`sparsevec`](@ref)는 (행) 인덱스 벡터 `I`와 값 벡터 `V`를 받아  `R[I[k]] = V[k]`를 만족하는 희소 행렬을 만든다.

```jldoctest sparse_function
julia> I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];

julia> S = sparse(I,J,V)
5×18 SparseMatrixCSC{Int64,Int64} with 4 stored entries:
  [1 ,  4]  =  1
  [4 ,  7]  =  2
  [5 ,  9]  =  3
  [3 , 18]  =  -5

julia> R = sparsevec(I,V)
5-element SparseVector{Int64,Int64} with 4 stored entries:
  [1]  =  1
  [3]  =  -5
  [4]  =  2
  [5]  =  3
```

[`sparse`](@ref) 함수와 [`sparsevec`](@ref) 함수의 역은 [`findnz`](@ref)이다.
`findnz`는 희소 행렬의 인덱스 벡터와 값 벡터를 리턴한다.
또한 인덱스 벡터만을 리턴하는 [`findn`](@ref)도 있다.

```jldoctest sparse_function
julia> findnz(S)
([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])

julia> findn(S)
([1, 4, 5, 3], [4, 7, 9, 18])

julia> findnz(R)
([1, 3, 4, 5], [1, -5, 2, 3])

julia> find(!iszero, R)
4-element Array{Int64,1}:
 1
 3
 4
 5
```

[`sparse`](@ref) 함수를 사용하여 밀집 배열을 희소 배열로 바꾸는 것 또한 가능하다:

```jldoctest
julia> sparse(Matrix(1.0I, 5, 5))
5×5 SparseMatrixCSC{Float64,Int64} with 5 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
  [4, 4]  =  1.0
  [5, 5]  =  1.0

julia> sparse([1.0, 0.0, 1.0])
3-element SparseVector{Float64,Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0
```

[`Array`](@ref) 생성자를 사용하여 반대방향의 변환도 가능하다.
[`issparse`](@ref) 함수를 사용하여 희소 배열인지 확인할 수 있다.

```jldoctest
julia> issparse(spzeros(5))
true
```

### 희소 행렬 연산

희소 배열에 대한 산술 연산은 밀집 배열에서처럼 동작한다.
희소 배열의 인덱싱, 대입, 그리고 병합 모두 밀집 배열과 마찬가지로 동작한다.
인덱싱 연산, 그리고 특히 대입 연산을 원소 하나씩 하는 것은 비싸다.
희소 행렬을 [`findnz`](@ref)를 사용하여 `(I,J,V)` 포맷으로 변경한 후, 밀집 벡터인 `I`, `J`, `V`의 구조나 값을 변경한 다음, 다시 희소 행렬을 생성하는 편이 오히려 더 나은 경우가 많다.

### 밀집 메소드와 희소 메소드 간의 대응

다음의 표는 희소 행렬의 내장 메소드와 이에 대응하는 밀집 행렬의 메소드를 담고있다.
일반적으로 희소 행렬을 생성하는 메소드가 그에 대응하는 밀집 행렬 메소드와 다른 점은,
결과 행렬이 주어진 희소 행렬 `S`의 희소성 패턴을 따르거나, 결과 희소 행렬의 밀도가 `d`이라는 것이다.
(즉, 행렬의 각 원소가 0이 아닐 확률이 `d`이다.)

자세한 내용은 표준 라이브러리 레퍼런스의 [밀집 벡터와 행렬](@ref stdlib-sparse-arrays)을 참조하기 바란다.

| 희소                       | 밀집                   | 설명                                                                                                                                                               |
|:-------------------------- |:---------------------- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [`spzeros(m,n)`](@ref)     | [`zeros(m,n)`](@ref)   | 크기가 `m` × `n` 인 0의 행렬을 생성한다. ([`spzeros(m,n)`](@ref) 는 빈 행렬이다.)                                                                                  |
| [`sparse(I, n, n)`](@ref)  | [`Matrix(I,n,n)`](@ref)| 크기가 `m` × `n` 인 단위 행렬을 생성한다.                                                                                                                          |
| [`Array(S)`](@ref)         | [`sparse(A)`](@ref)    | 밀집 행렬과 희소 행렬을 상호 변환한다.                                                                                                                             |
| [`sprand(m,n,d)`](@ref)    | [`rand(m,n)`](@ref)    | 크기가 `m` × `n` 인 랜덤 행렬을 생성한다. 생성되는 행렬의 밀도는 `d`이며, 0이 아닌 원소는 독립 동일하게 반열린구간 ``[0, 1)``에서의 연속 균등 분포를 따른다.       |
| [`sprandn(m,n,d)`](@ref)   | [`randn(m,n)`](@ref)   | 크기가 `m` × `n` 인 랜덤 행렬을 생성한다. 생성되는 행렬의 밀도는 `d`이며, 0이 아닌 원소는 독립 동일하게 표준 정규 분포를 따른다.                                   |
| [`sprandn(m,n,d,X)`](@ref) | [`randn(m,n,X)`](@ref) | 크기가 `m` × `n` 인 랜덤 행렬을 생성한다. 생성되는 행렬의 밀도는 `d`이며, 0이 아닌 원소는 독립 동일하게 `X` 분포를 따른다. (`Distributions` 패키지를 필요로 한다.) |
